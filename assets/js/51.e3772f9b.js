(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{342:function(t,e,s){"use strict";s.r(e);var a=s(14),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6844904205371588615",target:"_blank",rel:"noopener noreferrer"}},[t._v("参链1：前端面试必考题：React Hooks 原理剖析"),e("OutboundLink")],1),e("br"),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/6844904202267787277",target:"_blank",rel:"noopener noreferrer"}},[t._v("参链2：React Fiber原理解析"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_1-react-fiber原理解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-react-fiber原理解析"}},[t._v("#")]),t._v(" 1. React Fiber原理解析")]),t._v(" "),e("p",[t._v("参链2")]),t._v(" "),e("ol",[e("li",[t._v("从stack reconciliation重构成fiber reconciliation。")]),t._v(" "),e("li",[t._v("原因：V15.X会出现掉帧现象，因为JS运算、页面布局、页面绘制都会阻塞主线程。")]),t._v(" "),e("li",[t._v("解决：分片任务，fiber自己实现了组件调用栈，以链表的形式遍历组件树，利用了浏览器"),e("strong",[t._v("requestIdleCallback")]),t._v("的API")]),t._v(" "),e("li",[t._v("总结：通过Fiber架构，"),e("strong",[t._v("让自己的Reconciliation过程变得可被中断，适时地让出CPU执行权，可以让浏览器及时地响应用户的交互")])])]),t._v(" "),e("h2",{attrs:{id:"_2-hooks原理剖析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-hooks原理剖析"}},[t._v("#")]),t._v(" 2. Hooks原理剖析")]),t._v(" "),e("p",[t._v("参链1")]),t._v(" "),e("ol",[e("li",[t._v("从类组件转向函数组件")]),t._v(" "),e("li",[t._v("useState和useReducer都是关于值的状态和更新，本质上没有区别。useState是useReducer的简化版")]),t._v(" "),e("li",[t._v("保存状态：Hooks和类组件"),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" 两者的状态值都是挂载在组件实例对象FiberNode的memoizedState属性中\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v(" 保存的数据结构完全不同：类组件就是直接保存到memoizedState中，而Hooks是用链表的数据结构保存的，\n实际保存是的链表的头指针。\n")])])])]),t._v(" "),e("li",[t._v("hooks如何更新状态：异步更新，创建一条修改记录，在对应Hook的queue属性挂载的"),e("strong",[t._v("链表上新增一个节点")]),t._v("。")]),t._v(" "),e("li",[t._v("useEffect："),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" 保存方式是以链表的形式挂载在FiberNode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("updateQueue中\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v(" 执行阶段"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("commitHookEffectList")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("，\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.1")]),t._v(" 遍历链表\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.2")]),t._v(" 如果遇到Effect"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tag被标记上NoHookEffect的节点则跳过。\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.3")]),t._v(" 如果Effect"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("destroy为函数类型，则需要执行该清除副作用的函数\n    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.4")]),t._v(" 执行Effect"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("create，并将执行结果保存到Effect"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("destroy\n    （如果开发者没有配置"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("，那得到的自然是"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),t._v("了，也就是说，开发者认为对于当前 useEffect 代码段，不存在需要清除的副作用）；\n    注意由于闭包的缘故，Effect"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("destroy实际上可以访问到本次Effect"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("create函数作用域内的变量。\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v(" 是先清除上一轮的副作用，然后再执行本轮的 effect 的。\n")])])])])])])}),[],!1,null,null,null);e.default=n.exports}}]);