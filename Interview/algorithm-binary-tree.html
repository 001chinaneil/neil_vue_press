<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>二叉树系列集--进阶算法开始 todo | 持续变强</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="学习笔记">
    
    <link rel="preload" href="/neil_vue_press/assets/css/0.styles.b423781f.css" as="style"><link rel="preload" href="/neil_vue_press/assets/js/app.ce6058cf.js" as="script"><link rel="preload" href="/neil_vue_press/assets/js/2.616e7873.js" as="script"><link rel="preload" href="/neil_vue_press/assets/js/1.6e2e3eb2.js" as="script"><link rel="preload" href="/neil_vue_press/assets/js/28.1b582b51.js" as="script"><link rel="prefetch" href="/neil_vue_press/assets/js/10.c2ddce70.js"><link rel="prefetch" href="/neil_vue_press/assets/js/100.2cb9245d.js"><link rel="prefetch" href="/neil_vue_press/assets/js/101.1e358b93.js"><link rel="prefetch" href="/neil_vue_press/assets/js/102.55fdfb04.js"><link rel="prefetch" href="/neil_vue_press/assets/js/103.b80c8053.js"><link rel="prefetch" href="/neil_vue_press/assets/js/104.979131ae.js"><link rel="prefetch" href="/neil_vue_press/assets/js/105.a1956f88.js"><link rel="prefetch" href="/neil_vue_press/assets/js/106.3ecdcf48.js"><link rel="prefetch" href="/neil_vue_press/assets/js/107.42e05011.js"><link rel="prefetch" href="/neil_vue_press/assets/js/108.ad556a13.js"><link rel="prefetch" href="/neil_vue_press/assets/js/109.2ba7058b.js"><link rel="prefetch" href="/neil_vue_press/assets/js/11.845e3692.js"><link rel="prefetch" href="/neil_vue_press/assets/js/110.ee3de1be.js"><link rel="prefetch" href="/neil_vue_press/assets/js/12.10f4b7b2.js"><link rel="prefetch" href="/neil_vue_press/assets/js/13.dba8623a.js"><link rel="prefetch" href="/neil_vue_press/assets/js/14.259dac0a.js"><link rel="prefetch" href="/neil_vue_press/assets/js/15.b60f3925.js"><link rel="prefetch" href="/neil_vue_press/assets/js/16.b796cb59.js"><link rel="prefetch" href="/neil_vue_press/assets/js/17.c2838453.js"><link rel="prefetch" href="/neil_vue_press/assets/js/18.3256f17f.js"><link rel="prefetch" href="/neil_vue_press/assets/js/19.d3e902f6.js"><link rel="prefetch" href="/neil_vue_press/assets/js/20.a728a170.js"><link rel="prefetch" href="/neil_vue_press/assets/js/21.8f6f4046.js"><link rel="prefetch" href="/neil_vue_press/assets/js/22.6180816b.js"><link rel="prefetch" href="/neil_vue_press/assets/js/23.3c2328ca.js"><link rel="prefetch" href="/neil_vue_press/assets/js/24.78abee10.js"><link rel="prefetch" href="/neil_vue_press/assets/js/25.d061ec60.js"><link rel="prefetch" href="/neil_vue_press/assets/js/26.67bd2e77.js"><link rel="prefetch" href="/neil_vue_press/assets/js/27.4d5b3ea3.js"><link rel="prefetch" href="/neil_vue_press/assets/js/29.046359c9.js"><link rel="prefetch" href="/neil_vue_press/assets/js/3.a6d02328.js"><link rel="prefetch" href="/neil_vue_press/assets/js/30.143f6735.js"><link rel="prefetch" href="/neil_vue_press/assets/js/31.80ba92d3.js"><link rel="prefetch" href="/neil_vue_press/assets/js/32.cb7ea2f7.js"><link rel="prefetch" href="/neil_vue_press/assets/js/33.d40c5d8a.js"><link rel="prefetch" href="/neil_vue_press/assets/js/34.a10b04f5.js"><link rel="prefetch" href="/neil_vue_press/assets/js/35.54845dae.js"><link rel="prefetch" href="/neil_vue_press/assets/js/36.cfafa0da.js"><link rel="prefetch" href="/neil_vue_press/assets/js/37.3e5d624d.js"><link rel="prefetch" href="/neil_vue_press/assets/js/38.a5a958bc.js"><link rel="prefetch" href="/neil_vue_press/assets/js/39.d05ad086.js"><link rel="prefetch" href="/neil_vue_press/assets/js/4.04fd32fe.js"><link rel="prefetch" href="/neil_vue_press/assets/js/40.bb947383.js"><link rel="prefetch" href="/neil_vue_press/assets/js/41.de491c94.js"><link rel="prefetch" href="/neil_vue_press/assets/js/42.0a776717.js"><link rel="prefetch" href="/neil_vue_press/assets/js/43.038a8d56.js"><link rel="prefetch" href="/neil_vue_press/assets/js/44.c7acfc0e.js"><link rel="prefetch" href="/neil_vue_press/assets/js/45.e7ebfbcf.js"><link rel="prefetch" href="/neil_vue_press/assets/js/46.316704dd.js"><link rel="prefetch" href="/neil_vue_press/assets/js/47.6771bc4a.js"><link rel="prefetch" href="/neil_vue_press/assets/js/48.9938ad53.js"><link rel="prefetch" href="/neil_vue_press/assets/js/49.ff90db2c.js"><link rel="prefetch" href="/neil_vue_press/assets/js/5.0aa2b161.js"><link rel="prefetch" href="/neil_vue_press/assets/js/50.3196afa1.js"><link rel="prefetch" href="/neil_vue_press/assets/js/51.e3772f9b.js"><link rel="prefetch" href="/neil_vue_press/assets/js/52.2f6cbd27.js"><link rel="prefetch" href="/neil_vue_press/assets/js/53.fc12321e.js"><link rel="prefetch" href="/neil_vue_press/assets/js/54.7a7c4e21.js"><link rel="prefetch" href="/neil_vue_press/assets/js/55.b21d1be6.js"><link rel="prefetch" href="/neil_vue_press/assets/js/56.40699bad.js"><link rel="prefetch" href="/neil_vue_press/assets/js/57.a07bc75d.js"><link rel="prefetch" href="/neil_vue_press/assets/js/58.5beb39bc.js"><link rel="prefetch" href="/neil_vue_press/assets/js/59.c2ffae8c.js"><link rel="prefetch" href="/neil_vue_press/assets/js/6.5ff9fa87.js"><link rel="prefetch" href="/neil_vue_press/assets/js/60.991c757f.js"><link rel="prefetch" href="/neil_vue_press/assets/js/61.a6514398.js"><link rel="prefetch" href="/neil_vue_press/assets/js/62.e08e24fb.js"><link rel="prefetch" href="/neil_vue_press/assets/js/63.8386491e.js"><link rel="prefetch" href="/neil_vue_press/assets/js/64.a14853d9.js"><link rel="prefetch" href="/neil_vue_press/assets/js/65.a17567bb.js"><link rel="prefetch" href="/neil_vue_press/assets/js/66.d5d1e04a.js"><link rel="prefetch" href="/neil_vue_press/assets/js/67.1bfda088.js"><link rel="prefetch" href="/neil_vue_press/assets/js/68.6533e609.js"><link rel="prefetch" href="/neil_vue_press/assets/js/69.fb54d3b7.js"><link rel="prefetch" href="/neil_vue_press/assets/js/7.8850a23c.js"><link rel="prefetch" href="/neil_vue_press/assets/js/70.7b7df945.js"><link rel="prefetch" href="/neil_vue_press/assets/js/71.998c2e96.js"><link rel="prefetch" href="/neil_vue_press/assets/js/72.ca6a4db9.js"><link rel="prefetch" href="/neil_vue_press/assets/js/73.069571b5.js"><link rel="prefetch" href="/neil_vue_press/assets/js/74.18db3841.js"><link rel="prefetch" href="/neil_vue_press/assets/js/75.a852404f.js"><link rel="prefetch" href="/neil_vue_press/assets/js/76.06c7645f.js"><link rel="prefetch" href="/neil_vue_press/assets/js/77.a5b01d75.js"><link rel="prefetch" href="/neil_vue_press/assets/js/78.cafc53e7.js"><link rel="prefetch" href="/neil_vue_press/assets/js/79.b81b3a53.js"><link rel="prefetch" href="/neil_vue_press/assets/js/80.b1be442d.js"><link rel="prefetch" href="/neil_vue_press/assets/js/81.c7aae388.js"><link rel="prefetch" href="/neil_vue_press/assets/js/82.45aa3e6d.js"><link rel="prefetch" href="/neil_vue_press/assets/js/83.6395039d.js"><link rel="prefetch" href="/neil_vue_press/assets/js/84.c3765f18.js"><link rel="prefetch" href="/neil_vue_press/assets/js/85.02c6c2d7.js"><link rel="prefetch" href="/neil_vue_press/assets/js/86.b1d91626.js"><link rel="prefetch" href="/neil_vue_press/assets/js/87.58091c3f.js"><link rel="prefetch" href="/neil_vue_press/assets/js/88.b19349dc.js"><link rel="prefetch" href="/neil_vue_press/assets/js/89.32ae16c9.js"><link rel="prefetch" href="/neil_vue_press/assets/js/90.5dea43f5.js"><link rel="prefetch" href="/neil_vue_press/assets/js/91.355ef21c.js"><link rel="prefetch" href="/neil_vue_press/assets/js/92.c6f036f6.js"><link rel="prefetch" href="/neil_vue_press/assets/js/93.3e70ded6.js"><link rel="prefetch" href="/neil_vue_press/assets/js/94.3602f9b0.js"><link rel="prefetch" href="/neil_vue_press/assets/js/95.85b9ef99.js"><link rel="prefetch" href="/neil_vue_press/assets/js/96.15dca093.js"><link rel="prefetch" href="/neil_vue_press/assets/js/97.cfefcb22.js"><link rel="prefetch" href="/neil_vue_press/assets/js/98.398cea51.js"><link rel="prefetch" href="/neil_vue_press/assets/js/99.06c5735b.js"><link rel="prefetch" href="/neil_vue_press/assets/js/vendors~docsearch.3d49b2ab.js">
    <link rel="stylesheet" href="/neil_vue_press/assets/css/0.styles.b423781f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/neil_vue_press/" class="home-link router-link-active"><!----> <span class="site-name">持续变强</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/neil_vue_press/topic/" class="nav-link">
  专题学习
</a></div><div class="nav-item"><a href="/neil_vue_press/Interview/" class="nav-link router-link-active">
  理论学习
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/neil_vue_press/topic/" class="nav-link">
  专题学习
</a></div><div class="nav-item"><a href="/neil_vue_press/Interview/" class="nav-link router-link-active">
  理论学习
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础知识（CSS&amp;JS）</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架原理（Vue&amp;React）</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编译打包</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法思想</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/neil_vue_press/Interview/algorithm-summary.html" class="sidebar-link">算法思想总结</a></li><li><a href="/neil_vue_press/Interview/algorithm-sort.html" class="sidebar-link">排序算法系列</a></li><li><a href="/neil_vue_press/Interview/algorithm-print.html" class="sidebar-link">各种输出系列</a></li><li><a href="/neil_vue_press/Interview/algorithm-write-theory.html" class="sidebar-link">实现原理编码</a></li><li><a href="/neil_vue_press/Interview/algorithm-de-weight.html" class="sidebar-link">去重专题系列</a></li><li><a href="/neil_vue_press/Interview/algorithm-array.html" class="sidebar-link">数组操作系列--正经算法开始 todo</a></li><li><a href="/neil_vue_press/Interview/algorithm-linked-list.html" class="sidebar-link">链表专题系列</a></li><li><a href="/neil_vue_press/Interview/algorithm-hash.html" class="sidebar-link">哈希操作系列</a></li><li><a href="/neil_vue_press/Interview/algorithm-string.html" class="sidebar-link">字符操作系列 todo</a></li><li><a href="/neil_vue_press/Interview/algorithm-pointer.html" class="sidebar-link">双指针系列集</a></li><li><a href="/neil_vue_press/Interview/algorithm-stack-and-queue.html" class="sidebar-link">栈与队列系列</a></li><li><a href="/neil_vue_press/Interview/algorithm-binary-tree.html" aria-current="page" class="active sidebar-link">二叉树系列集--进阶算法开始 todo</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/neil_vue_press/Interview/algorithm-binary-tree.html#一、理论基础" class="sidebar-link">一、理论基础</a></li><li class="sidebar-sub-header"><a href="/neil_vue_press/Interview/algorithm-binary-tree.html#二、树的遍历-介绍" class="sidebar-link">二、树的遍历--介绍</a></li><li class="sidebar-sub-header"><a href="/neil_vue_press/Interview/algorithm-binary-tree.html#三、运用递归解决问题" class="sidebar-link">三、运用递归解决问题</a></li></ul></li><li><a href="/neil_vue_press/Interview/algorithm-binary-tree-levelorder.html" class="sidebar-link">二叉树系列集--层序遍历实战</a></li><li><a href="/neil_vue_press/Interview/algorithm-binary-tree-practice.html" class="sidebar-link">二叉树系列集--实战实践集合</a></li><li><a href="/neil_vue_press/Interview/algorithm-recall.html" class="sidebar-link">回溯算法系列 todo</a></li><li><a href="/neil_vue_press/Interview/algorithm-greed.html" class="sidebar-link">贪心算法系列 todo</a></li><li><a href="/neil_vue_press/Interview/algorithm-dynamic-programming.html" class="sidebar-link">动态规划系列 todo</a></li><li><a href="/neil_vue_press/Interview/algorithm-dull-stack.html" class="sidebar-link">单调栈系列集 todo</a></li><li><a href="/neil_vue_press/Interview/algorithm-others.html" class="sidebar-link">其他未分类集</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="二叉树系列集-进阶算法开始-todo"><a href="#二叉树系列集-进阶算法开始-todo" class="header-anchor">#</a> 二叉树系列集--进阶算法开始 todo</h1> <p>20220122 海淀图书馆（北区）F3 第二遍 第7节 二叉树周末总结学完了</p> <ul><li><a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/x63shc/" target="_blank" rel="noopener noreferrer">LeetCode教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="一、理论基础"><a href="#一、理论基础" class="header-anchor">#</a> 一、理论基础</h2> <h3 id="种类枚举"><a href="#种类枚举" class="header-anchor">#</a> 种类枚举：</h3> <ul><li>种类：满二叉树和完全二叉树。</li> <li><strong>满二叉树</strong>：如果一棵二叉树只有度为0和度为2的节点，并且度为0的节点在同一层上，则这棵二叉树为满二叉树。有(2^K)-1个节点。</li> <li><strong>完全二叉树</strong>：除了最底层节点没有填满外，其余节点都填完了，而且最底层也是集中在最左侧的位置。节点范围1 ~ (2^K)-1。</li> <li>优先级队列就是一个堆，堆就是一棵完全二叉树，保证父子节点的顺序关系。</li> <li><strong>二叉搜索树</strong>：是有序树，左 &lt; 根 &lt; 右</li> <li><strong>平衡二叉搜索树</strong>AVL（Adelson-Velsky and Landis）：它是一棵空树或它的<strong>左右两个子树的高度差不超过1</strong>，并且左右2个子树都是平衡二叉树。</li></ul> <h3 id="存储方式"><a href="#存储方式" class="header-anchor">#</a> 存储方式</h3> <ul><li>链式存储（用指针），顺序存储（用数组）</li></ul> <h3 id="二叉树的定义"><a href="#二叉树的定义" class="header-anchor">#</a> 二叉树的定义</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// JS版本</span>
<span class="token keyword">function</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">===</span><span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> val<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token punctuation">(</span>left<span class="token operator">===</span><span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> left<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token punctuation">(</span>right<span class="token operator">===</span><span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> right<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="二、树的遍历-介绍"><a href="#二、树的遍历-介绍" class="header-anchor">#</a> 二、树的遍历--介绍</h2> <ul><li><ol><li>前序遍历：根左右；中序遍历：左根右；后序遍历：左右根；(<code>前中后序依【根】定，左右孩子不变更</code>) 这个顺序是打印输出的顺序</li></ol></li> <li><ol start="2"><li>对于二叉搜索树，通过【中序遍历】可以得到一个递增的有序数列。</li></ol></li> <li><ol start="3"><li>当删除节点时，将按照【后序遍历】的方式进行，即先删除左子树，再删除右子树，最后再删除中节点。</li></ol></li> <li><ol start="4"><li>递归算法的方法论：<br>
4.1 确定递归算法的参数和返回值(<code>确定参数和返值</code>)<br>
4.2 确定终止条件，防止栈溢出(<code>终止条件要说明，防止溢出来破坏</code>)<br>
4.3 确定单层递归逻辑(<code>核心逻辑是单层</code>)</li></ol></li> <li><ol start="5"><li>具体代码实现：递归解法，这个解法可以应对前序遍历、中序遍历、后序遍历，只不过是遍历算法里面的先后顺序换一下</li></ol></li></ul> <h3 id="遍历方式"><a href="#遍历方式" class="header-anchor">#</a> 遍历方式</h3> <ul><li>深度优先遍历：先往深走，遇到叶子节点再往回走</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>前序遍历（递归法，迭代法）
中序遍历（递归法，迭代法）
后序遍历（递归法，迭代法）
</code></pre></div><ul><li>广度优先遍历：一层一层的去遍历</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>层次遍历（迭代法）  
</code></pre></div><p>总结：</p> <ol><li>用递归的方式深度遍历比较方便，而栈是递归的一种实现结构，所以深度遍历都可以用栈而非递归的方式去实现。</li> <li>广度优先一般用队列的结构来实现。</li></ol> <h3 id="递归版-递归三部曲"><a href="#递归版-递归三部曲" class="header-anchor">#</a> 递归版：递归三部曲</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">order</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">// 前序遍历preOrder</span>
    	result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      
        <span class="token comment">// 中序遍历inOrder</span>
        <span class="token comment">// order(root.left);</span>
      	<span class="token comment">// result.push(root.val);</span>
      	<span class="token comment">// order(root.right);</span>
      
        <span class="token comment">// 后序遍历postOrder</span>
        <span class="token comment">// order(root.left);</span>
        <span class="token comment">// order(root.right);</span>
      	<span class="token comment">// result.push(root.val);</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 利用了闭包</span>
    <span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="迭代版"><a href="#迭代版" class="header-anchor">#</a> 迭代版</h3> <p><strong>迭代法：前序遍历</strong>
20220122 done</p> <ul><li><ol><li>实现一：利用栈：先进后出，所以是先把右节点压栈，再把左节点压栈。</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 前序遍历：根左右</span>
<span class="token comment">// 利用栈：先进后出，所以是先把右节点压栈，再把左节点压栈。</span>
<span class="token comment">// 口诀：pop出栈，先右后左的压栈</span>
<span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 1. 定义返回值</span>
    <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 定义栈</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> temp <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2. 出栈取值</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3. 先右后左的压栈，这样出来的时候才是左、右</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>right<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      	<span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>left<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>迭代法：中序遍历</strong></p> <ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/" target="_blank" rel="noopener noreferrer">官方题解：<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/" target="_blank" rel="noopener noreferrer">「手画图解」用栈模拟中序遍历，怎么做以及为什么 | 递归与迭代：<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>实现一：利用栈TODO，口诀：2次左偏瘫(while循环，push(root) .left)，1次右一点；<strong>入栈能左就左，出栈查右</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 口诀：2次左偏瘫(while循环，push(root) .left)，1次右一点</span>
<span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 利用栈：先进后出的特性</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 1. 先把左节点全部压栈，其实是把 各个中心节点和左节点入了栈</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 2. 循环出栈</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 出栈</span>
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 取值，其实是把 左节点和中心节点取了值</span>
        root <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token comment">// 3. 中心、左入栈，左、中心出栈取值，右(中心)、子左入栈，子左、右(中心)出栈</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4. 右节点入栈啦 重点[右节点也是一定意义上的中心节点]</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>迭代法：后序遍历</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 20221022</span>
<span class="token comment">// 入参：root</span>
<span class="token comment">// 返回值：res数组</span>
<span class="token comment">// 后序遍历：左右中-翻转 =&gt; 中右左-出栈 =&gt; 中左右-入栈</span>
<span class="token keyword">const</span> <span class="token function-variable function">postOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> curr <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>前中后序统一迭代法</strong> 不好理解，TODO 二选一即可</p> <p><strong>层序遍历：</strong> 逐层遍历树结构</p> <ul><li><ol><li>广度优先搜索，多应用于树和图数据结构，进行遍历和搜索的算法 === 也就是用层序遍历顺序的。</li></ol></li> <li><ol start="2"><li>通常用队列的数据结构来帮助做广度优先搜索。</li></ol></li> <li><ol start="3"><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/" target="_blank" rel="noopener noreferrer">官方题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-bfs-by-zxh-51dl/" target="_blank" rel="noopener noreferrer">题解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 看懂了，搞一个队列，里面元素[val,level]，左右入队，一个个出队，入队列时进行标记：[[val,level]]。</li></ol></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 利用队列的特点：先进先出进行实现 shift</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 初始化，root，第0层，最好的记忆模板</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 最后逐层遍历顺序化的结果</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> <span class="token punctuation">[</span>n<span class="token punctuation">,</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 取出第一个数组，技巧写法</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            result<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>n<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 你要没有，咱就给你新增</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            result<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 你要是有，咱就给你push</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// 给队列新增元素</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>n<span class="token punctuation">.</span>left<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>right<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>n<span class="token punctuation">.</span>right<span class="token punctuation">,</span>level<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第二种解法</span>
<span class="token comment">// 20220123</span>
<span class="token comment">// 广度优先，层序遍历</span>
<span class="token comment">// 入参：root</span>
<span class="token comment">// 返回值：二维数组，里面每个数组元素是每层的节点</span>
<span class="token comment">// 核心逻辑：层与层的区别，记录当前层次的节点个数，去进行遍历；队列数据结构</span>
<span class="token keyword">const</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 临界情况</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 循环队列</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> currLevelLength <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment">// 当前层级节点的容器</span>
        <span class="token keyword">let</span> currLevelArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 当前层数有多少个节点，就循环遍历几次</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> currLevelLength<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> curr <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            currLevelArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 把当前节点的左右子树放入队列里面去</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
                queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>currLevelArr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="三、运用递归解决问题"><a href="#三、运用递归解决问题" class="header-anchor">#</a> 三、运用递归解决问题</h2> <p>递归是解决树相关问题的最常用、最有效的方法之一</p> <ul><li><a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefb4e/" target="_blank" rel="noopener noreferrer">官方链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 真是好例子，可以二刷总结，20220122二刷完成</li> <li><ol><li><code>关注每个单节点的问题</code>，通过函数调用来解决其他节点的问题。</li></ol></li> <li><ol start="2"><li>两种方式：《自上向下》、《自下向上》</li></ol></li> <li><ol start="3"><li>《自上向下》：如果可以从自身出发得到答案，并可以把有价值的参数传给子节点</li></ol></li> <li><ol start="4"><li>《自下向上》：如果已知子节点的答案，可以得到自身的答案，eg: 快排、斐波那契数列递归版</li></ol></li></ul> <h3 id="实际问题1-求二叉树的最大深度"><a href="#实际问题1-求二叉树的最大深度" class="header-anchor">#</a> 实际问题1：求二叉树的最大深度</h3> <ul><li>递归和迭代算是一种算法思想，栈和队列算是一种特殊的数据结构。</li></ul> <p>方法1：深度优先搜索：递归</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxDep</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">maxDep</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  	<span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token function">maxDep</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方法2：广度优先搜索：迭代<br> <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/dai-ma-sui-xiang-lu-qiu-shu-de-zui-da-sh-f988/" target="_blank" rel="noopener noreferrer">参链<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>总结：层序遍历中的while中的内容是遍历的变化部分，根据不同的目的，进行不同的变化。比如层级打印、最大深度。</li></ul> <h3 id="实际问题2-验证对称二叉树"><a href="#实际问题2-验证对称二叉树" class="header-anchor">#</a> 实际问题2：验证对称二叉树</h3> <ul><li><a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoxzgv/" target="_blank" rel="noopener noreferrer">参链<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>思考：递归思想太牛逼了！！</li></ul> <p>方法1：递归算法：时间复杂度O(n)，空间复杂度O(1)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  	<span class="token keyword">function</span> <span class="token function">isMirror</span><span class="token punctuation">(</span><span class="token parameter">r1<span class="token punctuation">,</span>r2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 针对三种case 进行判断返回</span>
    	<span class="token keyword">if</span><span class="token punctuation">(</span>r1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> r2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>r1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> r2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        
      	<span class="token keyword">return</span> <span class="token punctuation">(</span>r1<span class="token punctuation">.</span>val <span class="token operator">==</span> r2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
				<span class="token function">isMirror</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>r2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
          		<span class="token function">isMirror</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>r2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
  	<span class="token keyword">return</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方法2：迭代算法：设计一个队列，两两入队，两两出队，进行比较，[入队逻辑是关键]</p> <ul><li>总结：队列的数据结构太牛逼了！！</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// arr.push(a1,a2,a3) =&gt; arr = [a1,a2,a3] push可以多元素</span>
<span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 迭代思想：设计一个队列，两两入队，两两出队，两两比较</span>
    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> r1 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> r2 <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 比较逻辑</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>r1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> r2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>r1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> r2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>val <span class="token operator">!=</span> r2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 两两入队 如此写法提升代码易读性</span>
        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>r2<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>r2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 如果上边逻辑全通过，说明是对称的</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="实际问题3-路径总和"><a href="#实际问题3-路径总和" class="header-anchor">#</a> 实际问题3：路径总和</h3> <ul><li>总结：<code>return关键字，只会退出当前函数</code>，不会全部推出再上一层的函数。</li></ul> <p><strong>递归</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">hasPathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> targetSum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">==</span> targetSum<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 利用或者的特性，遇到true就不向后执行了</span>
    <span class="token keyword">return</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>targetSum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">||</span> 
           <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>targetSum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">||</span> 
           <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>迭代</strong> TODO</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/neil_vue_press/Interview/algorithm-stack-and-queue.html" class="prev">
        栈与队列系列
      </a></span> <span class="next"><a href="/neil_vue_press/Interview/algorithm-binary-tree-levelorder.html">
        二叉树系列集--层序遍历实战
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/neil_vue_press/assets/js/app.ce6058cf.js" defer></script><script src="/neil_vue_press/assets/js/2.616e7873.js" defer></script><script src="/neil_vue_press/assets/js/1.6e2e3eb2.js" defer></script><script src="/neil_vue_press/assets/js/28.1b582b51.js" defer></script>
  </body>
</html>
